snippet lang "lang"
{-# LANGUAGE ${1:OverloadedStrings} #-}
endsnippet

snippet info "info"
-- |
-- Module      :  ${1:Module.Namespace}
-- Copyright   :  ${2:Author} ${3:2011-2012}
-- License     :  ${4:BSD3}
--
-- Maintainer  :  ${5:email@something.com}
-- Stability   :  ${6:experimental}
-- Portability :  ${7:unknown}
--
-- ${8:Description}
--
endsnippet

snippet import "import"
import           ${1:Data.Text}
endsnippet

snippet import2 "import2"
import           ${1:Data.Text} (${2:head})
endsnippet

snippet importq "importq"
import qualified ${1:Data.Text} as ${2:T}
endsnippet

snippet inst "inst"
instance ${1:Monoid} ${2:Type} where
	${3}
endsnippet

snippet type "type"
type ${1:Type} = ${2:Type}
endsnippet

snippet data "data"
data ${1:Type} = ${2:$1} ${3:Int}
endsnippet

snippet newtype "newtype"
newtype ${1:Type} = ${2:$1} ${3:Int}
endsnippet

snippet class "class"
class ${1:Class} a where
	${2}
endsnippet

snippet module "module"
module `!v substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (
)	where
`!v expand('%') =~ 'Main' ? "\n\nmain = do\n  print \"hello world\"" : ""`
endsnippet

snippet const "const"
${1:name} :: ${2:a}
$1 = ${3:undefined}
endsnippet

snippet fn "fn"
${1:fn} :: ${2:a} -> ${3:a}
$1 ${4} = ${5:undefined}
endsnippet

snippet fn2 "fn2"
${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
$1 ${5} = ${6:undefined}
endsnippet

snippet ap "ap"
${1:map} ${2:fn} ${3:list}
endsnippet

snippet do "do"
do
endsnippet

snippet λ "λ"
\${1:x} -> ${2}
endsnippet

snippet \ "\"
\${1:x} -> ${2}
endsnippet

snippet <- "<-"
${1:a} <- ${2:m a}
endsnippet

snippet ← "←"
${1:a} <- ${2:m a}
endsnippet

snippet -> "->"
${1:m a} -> ${2:a}
endsnippet

snippet → "→"
${1:m a} -> ${2:a}
endsnippet

snippet tup "tup"
(${1:a}, ${2:b})
endsnippet

snippet tup2 "tup2"
(${1:a}, ${2:b}, ${3:c})
endsnippet

snippet tup3 "tup3"
(${1:a}, ${2:b}, ${3:c}, ${4:d})
endsnippet

snippet rec "rec"
${1:Record} { ${2:recFieldA} = ${3:undefined}
			, ${4:recFieldB} = ${5:undefined}
			}
endsnippet

snippet case "case"
case ${1:something} of
	${2} -> ${3}
endsnippet

snippet let "let"
let ${1} = ${2}
in ${3}
endsnippet

snippet where "where"
where
	${1:fn} = ${2:undefined}
endsnippet


