# create package spec
snippet ps "ps"
create or replace package ${1:name}
as
	${2:-- spec}
end; -- end of package spec $1
endsnippet

# create package body
snippet pb "pb"
create or replace package body ${1:name}
as
	${2:-- body}
end; -- end of package body $1;
endsnippet

# package procedure spec
snippet pps "pps"
procedure ${1:name}(${2:args});
endsnippet

# package procedure body
snippet ppb "ppb"
procedure ${1:name}(${2:args})
as
begin
	${3:-- body}
end $2;
endsnippet

# package function spec
snippet pfs "pfs"
function ${1:name}(${2:args})
  return ${3:type};
endsnippet

# package function body
snippet pfb "pfb"
function ${1:name}(${2:args})
  return ${3:type}
as
	l_res	$3;
begin
	${4:-- body};
	return l_res;
end $1;
endsnippet

# snow errors
snippet err "err"
show errors;
endsnippet

# proc/func in parameter
snippet p "p"
${1:name} ${2:in} ${3:type} ${4: := null}
endsnippet

# package type: record
snippet tr "tr"
type tr_${1:name} is record (${2:/* columns */});
endsnippet

# package type: nested table
snippet tt "tt"
type tt_${1:name} is table of tr_${2:name};
endsnippet

# package type: indexed table
snippet tti "tti"
type tt_${1:name} is table of tr_${2:name} index by binary_integer;
endsnippet

# proc/func comment
snippet doc "doc"
/*
 *	${1: comment ...}
 */
endsnippet

# plsql block
snippet beg "beg"
begin
	${1}
end;
endsnippet

# plsql block with declare part
snippet dec "dec"
declare
	${1}
begin
	${2}
end;
endsnippet

# return pipe row
snippet rpipe "rpipe"
for ${1:i} in 1 .. ${2:l_res}.count loop
	pipe row( $2($1) );
end loop;
return;
endsnippet

# bulk collect
snippet bc "bc"
bulk collect into ${1}
endsnippet

# local variable
snippet l "l"
l_${1}		${2:number};
endsnippet

# output
snippet log "log"
dbms_output.put_line('${1}');
endsnippet

# for loop
snippet for "for"
for ${1:i} in ${2:1}..${3:42} loop
	${3}
end loop;
endsnippet

# for loop with select
snippet fors "fors"
for ${1:rec} in (${2: select}) loop
	${3}
end loop;
endsnippet

# for loop with collection
snippet forc "forc"
for ${1:i} in ${2:l_var}.first .. $2.last loop
	${3: -- dbms_output.put_line($2($1)); }
end loop;
endsnippet

# if
snippet if "if"
if ${1} then
	${2}
end if;
endsnippet

snippet ife "ife"
if ${1} then
	${2}
else
	${3}
end if;
endsnippet


